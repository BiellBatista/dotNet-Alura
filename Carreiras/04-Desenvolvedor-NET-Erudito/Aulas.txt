SOLID com C#: Orientação a Objetos com C#
	01 - Coesão e o Single Responsibility Principle
		01 - Vídeo 1
		02 - Vídeo 2
		03 - Vídeo 3
		04 - Vídeo 4
		05 - Coesão e o Single Responsibility Principle
		06 - Coesão
		07 - Detectando classes não coesas
		08 - O que fazer com classes não coesas?
		09 - SRP
		10 - Mão na massa
		11 - Interface Segregation Principle
	02 - Acoplamento e a estabilidade
		01 - Vídeo 1
		02 - Acoplamento e a estabilidade
		03 - Problema do acoplamento
		04 - Classes estáveis
		05 - Resolvendo problema do acoplamento
		06 - Mão na massa
	03 - Classes abertas, Open Closed e Dependency Inversion Principles
		01 - Vídeo 1
		02 - Classes abertas, Open Closed e Dependency Inversion Principles
		03 - OCP
		04 - DIP
		05 - OCP e DIP
		06 - Mão na massa!
	04 - Entendendo o encapsulamento
		01 - Vídeo 1
		02 - Entendendo o encapsulamento
		03 - O que é encapsulamento?
		04 - Descobrindo código não encapsulado
		05 - Lei de Demeter
		06 - Mão na massa!
	05 - Herança e o Liskov Substitutive Principle
		01 - Vídeo 1
		02 - Herança e o Liskov Substitutive Principle
		03 - Problemas da herança
		04 - Maneiras de reutilizar comportamento
		05 - Leia mais sobre Liskov
		06 - Mão na massa!
SOLID com C#: Orientação a Objetos com C# (novo)
	01 - Qualidade de software
		01 - Introdução
		02 - Objetivos do curso
		03 - Projeto inicial
		04 - Preparando o ambiente
		05 - Objetivos da aula
		06 - A história do projeto
		07 - Qualidade de software
		08 - Sinais de que você está repetindo código (A / B / D)
		09 - Executando a aplicação
		10 - Referências utilizadas (em inglês)
		11 - O que aprendemos?
	02 - Responsabilidade única
		01 - Objetivos da aula
		02 - Analisando o LeilaoController
		03 - Separando a lógica de acesso
		04 - Conceitos
		05 - Agentes de mudança (B / C / D)
		06 - Agentes de mudança em controladores (B)
		07 - Referências utilizadas (em inglês)
		08 - Criação do LeilaoDao
		09 - Projeto atual
		10 - O que aprendemos?
	03 - Inversão de dependências
		01 - Projeto da aula anterior
		02 - Objetivos da aula
		03 - Diga-me com quem andas
		04 - Dependências de EmpregadoManager (A / B / C / E / G / H)
		05 - EmpregadoManager II (B / G)
		06 - Uma abstração para o acesso aos dados
		07 - LeilaoDaoComEfCore
		08 - Injetando a dependência
		09 - Conceitos
		10 - Invertendo a dependência em nosso projeto
		11 - E o HomeController, Daniel?
		12 - Projeto atual
		13 - O que aprendemos?
	04 - Princípio do Aberto/Fechado
		01 - Objetivos da aula
		02 - Encontramos um defeito
		03 - Separando as funcionalidades
		04 - Ajude Daenerys em seu projeto (B)
		05 - Arquivando um leilão
		06 - Daniel, o enumerado ficou instável!
		07 - Conceitos
		08 - Camada de serviços
		09 - Sempre fechado? (A / C / E)
		10 - Para saber mais: O que eles têm em comum?
		11 - Referências utilizadas (em inglês)
		12 - Projeto atual
		13 - O que aprendemos?
	05 - Segregação de Interfaces e Liskov
		01 - Objetivos da aula
		02 - Quando OO vira uma pedra no sapato
		03 - Interfaces também perdem coesão
		04 - Ajustes finais
		05 - Conceitos
		06 - Criando interfaces separadas
		07 - Relacione os conceitos (B)
		08 - Referências utilizadas (em inglês)
		09 - Projeto final
		10 - O que aprendemos?
		11 - Conclusão
Design Patterns C# I: Boas práticas de programação
	01 - A grande variedade de impostos e o padrão Strategy
		01 - Vídeo 1
		02 - A grande variedade de impostos e o padrão Strategy
		03 - O que é um padrão de projeto?
		04 - Estudando a motivação dos padrões (A)
		05 - Implementando um Strategy
		06 - Estratégia para o imposto ICCC
		07 - Utilidade da classe CalculadoraDeImpostos
		08 - Estratégias para Investimentos
		09 - Strategy o tempo todo? (A)
		10 - Quando usar o Strategy?
	02 - Muitos Descontos e o Chain of Responsibility
		01 - Vídeo 1
		02 - Muitos Descontos e o Chain of Responsibility
		03 - Padrão Chain of Responsibility
		04 - Desconto por Venda Casada
		05 - Utilidade da classe CalculadorDeDescontos
		06 - Implementando Chain of Responsibility em Requisições Web
		07 - Recebendo o próximo ítem da corrente pelo construtor
		08 - Fim da corrente no Chain of Responsibility
		09 - Quando usar o Chain of Responsibility?
	03 - Códigos parecidos e o Template Method
		01 - Vídeo 1
		02 - Códigos parecidos e o Template Method
		03 - Padrão Template Method
		04 - Modificador de acesso em Template Method (C)
		05 - Imposto Z
		06 - Relatórios e Template Method
		07 - Chain of Responsibility e Template Method
		08 - Quando usar o Template Method?
	04 - Comportamentos compostos por outros comportamentos e o Decorator
		01 - Vídeo 1
		02 - Comportamentos compostos por outros comportamentos e o Decorator
		03 - O padrão Decorator
		04 - Criação de imposto muito alto com Decorator
		05 - Decorando IKCV e ICPP
		06 - Criando um Filtro
		07 - Quando usar o Decorator?
	05 - Estados que variam e o State
		01 - Vídeo 1
		02 - Estados que variam e o State
		03 - Padrão State
		04 - Desconto Extra aplicado uma única vez
		05 - Estados de uma conta bancária
		06 - State e o acesso aos atributos da classe principal (A)
		07 - Estados enxergando a implementação da classe
		08 - Quando usar o State?
	06 - Criação de objetos e o Builder
		01 - Vídeo 1
		02 - Criação de objetos e o Builder
		03 - Padrão Builder
		04 - Builder para Item da Nota
		05 - Builders ou construtores?
		06 - Parâmetros opcionais no builder
		07 - Renomeando método do Builder
		08 - Quando usar o Builder?
	07 - Executando diferentes ações e o Observer
		01 - Vídeo 1
		02 - Executando diferentes ações e o Observer
		03 - Padrão Observer
		04 - Observador Multiplicador do Saldo da Nota
		05 - Builder
		06 - Quando usar o Observer?
	08 - Além dos padrões de projeto
		01 - Além dos padrões de projeto
		02 - Qual é o padrão para o problema dos Vários Filtros? (A)
		03 - Qual é o padrão para o problema da Notificação de Sistemas Externos? (D)
		04 - Qual é o padrão para o problema dos Algoritmos Similares? (C)
		05 - Qual é o padrão para o problema do Contrato? (B)
		06 - Padrões de Projeto
		07 - O que voce pensa sobre Padrões de Projeto?
Design Patterns C# II: Boas práticas de programação
	01 - Fábricas e o problema de criação de objetos
		01 - Vídeo 1
		02 - Fábricas e o problema de criação de objetos
		03 - Escrevendo a fábrica
		04 - Nomenclatura
		05 - Factory e Builder
	02 - Muitos objetos e o Flyweight
		01 - Vídeo 1
		02 - Muitos objetos e o Flyweight
		03 - Notas Musicais
		04 - Melhorando a fábrica
		05 - O padrão Singleton
		06 - Outros usos de Flyweight
	03 - Salvando estados anteriores e o Memento
		01 - Vídeo 1
		02 - Salvando estados anteriores e o Memento
		03 - Criando a classe Contrato
		04 - Memento
		05 - Necessidade da Classe Estado
		06 - Problemas do memento
	04 - DSLs e o Interpreter
		01 - Vídeo 1
		02 - DSLs e o Interpreter
		03 - Expressões
		04 - Avaliando expressões
		05 - Novas expressões
		06 - Quando usar?
		07 - Raiz Quadrada
	05 - Estruturas de dados e o Visitor
		01 - Vídeo 1
		02 - Estruturas de dados e o Visitor
		03 - Mudando a interface Expressão
		04 - Aceitando o visitor
		05 - Escrevendo o Visitor
		06 - Novo Visitor
		07 - Métodos do Visitor
	06 - Bridges
		01 - Vídeo 1
	07 - Diferentes ações com Command
	08 - Adapter
	09 - Façades e Singletons
C# Refatoração Parte 1: Praticando refatoração de código
	01 - Extraindo métodos
	02 - Extraindo variáveis temporárias
	03 - Quebrando Variáveis e Preservando Parâmetros
	04 - Substituindo Método
	05 - Movendo Método e Campo
	06 - Extraindo e Incorporando Classe
	07 - Delegação e Intermediários
	08 - Estendendo Classes
C# Refatoração Parte 2: Refatorações baseadas em Orientação a Objetos
	01 - Encapsulamento e Orientação a Objetos
	02 - Lidando com Referências
	03 - Dos Códigos às Classes
	04 - Simplificando Expressões Condicionais
	05 - Condições com Orientação a Objetos
C# Refatoração Parte 3: Hierarquias de classes
	01 - Ajustando Parâmetros e Métodos
	02 - Criando parâmetros mais simples
	03 - Trabalhando melhor com códigos de erro e exceções
	04 - Descobrindo onde colocar campos e métodos
	05 - Extraindo superclasse, subclasse e interfaces
	06 - Aplicando herança e delegação